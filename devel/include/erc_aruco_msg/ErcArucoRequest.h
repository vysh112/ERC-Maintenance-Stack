// Generated by gencpp from file erc_aruco_msg/ErcArucoRequest.msg
// DO NOT EDIT!


#ifndef ERC_ARUCO_MSG_MESSAGE_ERCARUCOREQUEST_H
#define ERC_ARUCO_MSG_MESSAGE_ERCARUCOREQUEST_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace erc_aruco_msg
{
template <class ContainerAllocator>
struct ErcArucoRequest_
{
  typedef ErcArucoRequest_<ContainerAllocator> Type;

  ErcArucoRequest_()
    : tag1()
    , tag2()
    , tag3()
    , tag4()
    , tag5()
    , tag6()
    , tag7()
    , tag8()
    , tag9()
    , tag10()
    , tag11()
    , tag12()
    , tag13()
    , tag14()  {
      tag1.assign(0.0);

      tag2.assign(0.0);

      tag3.assign(0.0);

      tag4.assign(0.0);

      tag5.assign(0.0);

      tag6.assign(0.0);

      tag7.assign(0.0);

      tag8.assign(0.0);

      tag9.assign(0.0);

      tag10.assign(0.0);

      tag11.assign(0.0);

      tag12.assign(0.0);

      tag13.assign(0.0);

      tag14.assign(0.0);
  }
  ErcArucoRequest_(const ContainerAllocator& _alloc)
    : tag1()
    , tag2()
    , tag3()
    , tag4()
    , tag5()
    , tag6()
    , tag7()
    , tag8()
    , tag9()
    , tag10()
    , tag11()
    , tag12()
    , tag13()
    , tag14()  {
  (void)_alloc;
      tag1.assign(0.0);

      tag2.assign(0.0);

      tag3.assign(0.0);

      tag4.assign(0.0);

      tag5.assign(0.0);

      tag6.assign(0.0);

      tag7.assign(0.0);

      tag8.assign(0.0);

      tag9.assign(0.0);

      tag10.assign(0.0);

      tag11.assign(0.0);

      tag12.assign(0.0);

      tag13.assign(0.0);

      tag14.assign(0.0);
  }



   typedef boost::array<float, 3>  _tag1_type;
  _tag1_type tag1;

   typedef boost::array<float, 3>  _tag2_type;
  _tag2_type tag2;

   typedef boost::array<float, 3>  _tag3_type;
  _tag3_type tag3;

   typedef boost::array<float, 3>  _tag4_type;
  _tag4_type tag4;

   typedef boost::array<float, 3>  _tag5_type;
  _tag5_type tag5;

   typedef boost::array<float, 3>  _tag6_type;
  _tag6_type tag6;

   typedef boost::array<float, 3>  _tag7_type;
  _tag7_type tag7;

   typedef boost::array<float, 3>  _tag8_type;
  _tag8_type tag8;

   typedef boost::array<float, 3>  _tag9_type;
  _tag9_type tag9;

   typedef boost::array<float, 3>  _tag10_type;
  _tag10_type tag10;

   typedef boost::array<float, 3>  _tag11_type;
  _tag11_type tag11;

   typedef boost::array<float, 3>  _tag12_type;
  _tag12_type tag12;

   typedef boost::array<float, 3>  _tag13_type;
  _tag13_type tag13;

   typedef boost::array<float, 3>  _tag14_type;
  _tag14_type tag14;





  typedef boost::shared_ptr< ::erc_aruco_msg::ErcArucoRequest_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::erc_aruco_msg::ErcArucoRequest_<ContainerAllocator> const> ConstPtr;

}; // struct ErcArucoRequest_

typedef ::erc_aruco_msg::ErcArucoRequest_<std::allocator<void> > ErcArucoRequest;

typedef boost::shared_ptr< ::erc_aruco_msg::ErcArucoRequest > ErcArucoRequestPtr;
typedef boost::shared_ptr< ::erc_aruco_msg::ErcArucoRequest const> ErcArucoRequestConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::erc_aruco_msg::ErcArucoRequest_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::erc_aruco_msg::ErcArucoRequest_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::erc_aruco_msg::ErcArucoRequest_<ContainerAllocator1> & lhs, const ::erc_aruco_msg::ErcArucoRequest_<ContainerAllocator2> & rhs)
{
  return lhs.tag1 == rhs.tag1 &&
    lhs.tag2 == rhs.tag2 &&
    lhs.tag3 == rhs.tag3 &&
    lhs.tag4 == rhs.tag4 &&
    lhs.tag5 == rhs.tag5 &&
    lhs.tag6 == rhs.tag6 &&
    lhs.tag7 == rhs.tag7 &&
    lhs.tag8 == rhs.tag8 &&
    lhs.tag9 == rhs.tag9 &&
    lhs.tag10 == rhs.tag10 &&
    lhs.tag11 == rhs.tag11 &&
    lhs.tag12 == rhs.tag12 &&
    lhs.tag13 == rhs.tag13 &&
    lhs.tag14 == rhs.tag14;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::erc_aruco_msg::ErcArucoRequest_<ContainerAllocator1> & lhs, const ::erc_aruco_msg::ErcArucoRequest_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace erc_aruco_msg

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::erc_aruco_msg::ErcArucoRequest_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::erc_aruco_msg::ErcArucoRequest_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::erc_aruco_msg::ErcArucoRequest_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::erc_aruco_msg::ErcArucoRequest_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::erc_aruco_msg::ErcArucoRequest_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::erc_aruco_msg::ErcArucoRequest_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::erc_aruco_msg::ErcArucoRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "8c2277db7b92fad0602e09f16e8162a6";
  }

  static const char* value(const ::erc_aruco_msg::ErcArucoRequest_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x8c2277db7b92fad0ULL;
  static const uint64_t static_value2 = 0x602e09f16e8162a6ULL;
};

template<class ContainerAllocator>
struct DataType< ::erc_aruco_msg::ErcArucoRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "erc_aruco_msg/ErcArucoRequest";
  }

  static const char* value(const ::erc_aruco_msg::ErcArucoRequest_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::erc_aruco_msg::ErcArucoRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float32[3] tag1\n"
"float32[3] tag2\n"
"float32[3] tag3\n"
"float32[3] tag4\n"
"float32[3] tag5\n"
"float32[3] tag6\n"
"float32[3] tag7\n"
"float32[3] tag8\n"
"float32[3] tag9\n"
"float32[3] tag10\n"
"float32[3] tag11\n"
"float32[3] tag12\n"
"float32[3] tag13\n"
"float32[3] tag14\n"
;
  }

  static const char* value(const ::erc_aruco_msg::ErcArucoRequest_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::erc_aruco_msg::ErcArucoRequest_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.tag1);
      stream.next(m.tag2);
      stream.next(m.tag3);
      stream.next(m.tag4);
      stream.next(m.tag5);
      stream.next(m.tag6);
      stream.next(m.tag7);
      stream.next(m.tag8);
      stream.next(m.tag9);
      stream.next(m.tag10);
      stream.next(m.tag11);
      stream.next(m.tag12);
      stream.next(m.tag13);
      stream.next(m.tag14);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct ErcArucoRequest_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::erc_aruco_msg::ErcArucoRequest_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::erc_aruco_msg::ErcArucoRequest_<ContainerAllocator>& v)
  {
    s << indent << "tag1[]" << std::endl;
    for (size_t i = 0; i < v.tag1.size(); ++i)
    {
      s << indent << "  tag1[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.tag1[i]);
    }
    s << indent << "tag2[]" << std::endl;
    for (size_t i = 0; i < v.tag2.size(); ++i)
    {
      s << indent << "  tag2[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.tag2[i]);
    }
    s << indent << "tag3[]" << std::endl;
    for (size_t i = 0; i < v.tag3.size(); ++i)
    {
      s << indent << "  tag3[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.tag3[i]);
    }
    s << indent << "tag4[]" << std::endl;
    for (size_t i = 0; i < v.tag4.size(); ++i)
    {
      s << indent << "  tag4[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.tag4[i]);
    }
    s << indent << "tag5[]" << std::endl;
    for (size_t i = 0; i < v.tag5.size(); ++i)
    {
      s << indent << "  tag5[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.tag5[i]);
    }
    s << indent << "tag6[]" << std::endl;
    for (size_t i = 0; i < v.tag6.size(); ++i)
    {
      s << indent << "  tag6[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.tag6[i]);
    }
    s << indent << "tag7[]" << std::endl;
    for (size_t i = 0; i < v.tag7.size(); ++i)
    {
      s << indent << "  tag7[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.tag7[i]);
    }
    s << indent << "tag8[]" << std::endl;
    for (size_t i = 0; i < v.tag8.size(); ++i)
    {
      s << indent << "  tag8[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.tag8[i]);
    }
    s << indent << "tag9[]" << std::endl;
    for (size_t i = 0; i < v.tag9.size(); ++i)
    {
      s << indent << "  tag9[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.tag9[i]);
    }
    s << indent << "tag10[]" << std::endl;
    for (size_t i = 0; i < v.tag10.size(); ++i)
    {
      s << indent << "  tag10[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.tag10[i]);
    }
    s << indent << "tag11[]" << std::endl;
    for (size_t i = 0; i < v.tag11.size(); ++i)
    {
      s << indent << "  tag11[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.tag11[i]);
    }
    s << indent << "tag12[]" << std::endl;
    for (size_t i = 0; i < v.tag12.size(); ++i)
    {
      s << indent << "  tag12[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.tag12[i]);
    }
    s << indent << "tag13[]" << std::endl;
    for (size_t i = 0; i < v.tag13.size(); ++i)
    {
      s << indent << "  tag13[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.tag13[i]);
    }
    s << indent << "tag14[]" << std::endl;
    for (size_t i = 0; i < v.tag14.size(); ++i)
    {
      s << indent << "  tag14[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.tag14[i]);
    }
  }
};

} // namespace message_operations
} // namespace ros

#endif // ERC_ARUCO_MSG_MESSAGE_ERCARUCOREQUEST_H
